## 06장. 데이터베이스 객체 작성과 삭제

### 25강. 데이터베이스 객체

데이터베이스 객체란 테이블이나 뷰, 인덱스 등 데이터베이스 내에 정의하는 모든 것을 일컫는 말이다.<br/>
여기서 말하는 객체는 데이터베이스 내에 실체를 가지는 어떤 것을 의미한다.

객체의 종류에 따라 데이터베이스에 저장되는 내용도 달라진다.<br/>
객체는 이름을 가지고이이름은 겹치지 않도록 해야 한다.

데이터베이스 객체는 이름을 가지는데 다음과 같은 명명규칙(제약 사항)을 따른다.
1. 기존 이름이나 예약어와 중복하지 않는다.
2. 숫자로 시작할 수 없다.
3. 언더스코어(\_)이외의 기호는 사용할 수 없다.
4. 한글을 사용할 때는 더블쿼트(MySQL에서는 백쿼트)로 둘러싼다.
5. 시스템이 허용하는 길이를 초과하지 않는다.

데이터베이스 객체는 스키마라는 공간에 만들어진다.<br/>

> CREATE DATABASE 명령으로 생성된 데이터베이스를 스키마라고 한다.

따라서 객체의 이름이 같아도 스키마가 다르다면 상관이 없다.<br/>
이와 같은 특징때문에 데이터베이스 객체는 '스키마 객체'라 불리기도 한다.

<br/> 

### 26강. 테이블 작성/삭제/변경

```sql
-- 테이블 작성
CREATE TABLE 테이블명(열 정의1, 열 정의2, ...)

-- 테이블 삭제
DROP TABLE 테이블명

-- 테이블 변경
ALTER TABLE 테이블명 하부명령
```

> 열 정의<br/>
> ```sql
> 열명 자료형 [DEFAULT 기본값] [NULL|NOT NULL]
> ```

```sql
CREATE TABLE sample (
  no INTEGER NOT NULL,
  a VARCHAR(30),
  b DATE
);
```

- 삭제
DROP TABLE은 데이터베이스에서 테이블을 삭제한다. 이때 테이블에 저장된 데이터도 함께 삭제된다.<br/>
DELETE는 테이블 정의는 그대로 둔 채 데이터만 삭제한다. 이때 WHERE조건을 지정하지 않으면 테이블의 모든 행을 삭제할 수 있다.<br/>

하지만 DELETE 명령은 행 단위로 내부처리가 일어나므로 삭제할 행이 많다면 처리 속도가 늦어지게 된다.<br/>
이런 경우 DDL로 분류되는 TRUNCATE TABLE 명령으로 삭제하게 되면 모든 행을 빠르게 삭제할 수 있다.
```sql
TUNCATE TAHBLE 테이블명
```

- 열 추가
ALTER TABLE ADD로 테이블에 열을 추가할 수 있다.
```sql
ALTER TABLE 테이블명 ADD 열 정의
```

- 열 속성 변경
ALTER TABLE MODIFY로 열 이름은 변경할 수 없지만, 자료형이나 기본값, NOT NULL 제약 등의 속성을 변경할 수 있다.
```sql
ALTER TABLE 테이블명 MODIFY 열 정의
```
만약 자료형을 변경하게 되면 테이블에 들어간 데이터의 자료형 역시 바뀌게 되는데 처리과정에서 에러가 발생하면 ALTER TABLE 명령을 실행되지 않는다.

- 열 이름 변경
ALTER TABLE CHANGE로 열 이름과 열 속성을 변경할 수 있다.
```sql
ALTER TABLE 테이블명 CHANGE [기존 열 이름][신규 열 정의]
```

- 열 삭제
ALTER TABLE DROP으로 열을 삭제할 수 있다.
```sql
ALTER TABLE 테이블명 DROP 열명
```

<br/>

### 27강. 제약
 
테이블에 제약 조건을 설정함으로써 저장될 데이터를 제한할 수 있다.<br/>
예를 들어 NOT NULL 제약은 NULL 값이 저장되지 않도록 제한한다.

NOT NULL 제약 조건말고도 기본 키(Primary Key) 제약 조건이나 외래키 제약 조건 등이 있다.<br/>
이러한 제약은 테이블에 설정하는 것으로 테이블을 생성할 때 정의하거나 ALTER TABLE로 제약 조건을 설정하거나 변경할 수도 있다.

열에 대해 정의하는 제약을 '열 제약 조건'이라고 부른다.<br/>
만약 한 개의 제약 조건을 복수개의 열에 제약 조건을 거는 경우에는 '테이블 제약 조건'이라고 부른다.

제약에는 이름을 붙일 수 있는데 이름을 붙이는 것이 나중에 관리하기 쉬워지므로 가능한 한 이름을 붙이는 것을 권장한다.<br/>
제약 이름은 CONSTRAINT 키워드를 사용해서 지정할 수 있다.

```sql
CREATE TABLE sample (
  no INTEGER NOT NULL,
  sub_no INTEGER NOT NULL,
  name VARCHAR(30),
  CONSTRAINT pk_sample PRIMARY KEY (no, sub_no)
);
```

기존 테이블에 나중에 제약을 추가/삭제 할 수 있다.

- 열 제약 추가

```sql
ALTER TABLE sample MODIFY c VARCHAR(30) NOT NULL;
```

- 테이블 제약 추가

```sql
ALTER TABLE sample ADD CONSTRAINT pk_sample PRIMARY KEY(a);
```

- 제약 삭제
```sql
ALTER TABLE sample MODIFY c VARCHAR(30);
```

- 테이블 제약 삭제

```sql
ALTER TABLE sample DROP CONSTRAINT pk_sample;
```


**- 기본키** 

기본키 제약 조건
- 기본키로 지정할 열은 NOT NULL 제약이 설정되어 있어야 한다.
- 기본키로 설정된 열이 중복하는 데이터 값을 가지면 제약 조건에 위배된다.

```sql
CREATE TABLE sample (
  p INTEGER NOT NULL,
  a VARCHAR(30),
  CONSTRAINT pk_sample PRIMARY KEY(p)
);
```
```sql
INSERT INTO sample VALUES(1, '첫째줄'); // OK
INSERT INTO sample VALUES(2, '둘째줄'); // OK

INSERT INTO sample VALUES(1, '첫째줄'); // ERROR
UPDATE sample SET p=1 WHERE p=2;        // ERROR
```

기본 키를 구성하는 열은 복수개여도 상관없다.<br/>
만약 복수의 열을 기본키로 지정할 경우 키를 구성하는 모든 열을 사용해서 중복하는 값이 있는지 없는지를 검사한다.<br/>
예를 들어, a열과 b열이 기본키로 설정되어 있을 경우 다음의 테이블은 기본키 제약 조건에 위배되지 않는다.

|a|b|
|--|--|
|1|1|
|1|2|
|1|3|
|2|1|
|2|2|

<br/>

### 28강. 인덱스 구조

인덱스는 테이블에 붙여진 색인으로 주된 역할은 검색 속도 향상이다.<br/>
여기서 말하는 '검색'은 SELECT로 특정 행을 찾는 과정을 말한다.

인덱스의 구조도 책의 목차나 색인과 비슷하게 검색 시에 쓰이는 키워드와 그에 대응하는 데이터 행의 저장소가 저장되어 있다.<br/>
인덱스는 테이블과 별개로 독립된 데이터베이스 객체에 저장된다. 

**검색에 사용하는 알고리즘**

- 풀 테이블 스캔(full table scan)

인덱스가 지정되지 않은 테이블을 검색할 때는 풀 테이블 스캔이라 불리는 검색 방법을 사용한다.<br/>
처리 방법은 단순히 테이블에 저장된 모든 값을 처음부터 차례로 조사해나가는 것이다.

- 이진 탐색(binary search)

차례로 나열된 집합에 대해 처음부터 순서대로 조사하는 것이 아닌 조건에 따라 집합을 반으로 나누어 조사하는 검색 방법이다.

- 이진 트리(binary tree)

이진 탐색으로 빠르게 검색할 수 있는 탐색이지만 데이터가 미리 정렬되어 있어야 하는 단점이 존재한다.<br/>
일반적으로 테이블에 인덱스를 지정하면 테이블 데이터와 별개로 인덱스용 데이터용 저장장치가 만들어진다.<br/>
이때 이 저장소는 이진 트리라는 데이터 구조로 작성된다.

**유일성**

이진 트리의 구조를 살피다 보면 같은 값을 가지는 노드가 여러 개 있을 때의 결과에 의문이 생길 수 있다.<br/>
사실 이진 트리에서는 집합 내에 중복하는 값을 가질 수 없다.<br/>
하지만 이진 트리에서 "같은 값을 가지는 노드를 여러개 만들 수 없다"라는 특성은 키에 대하여 유일성을 가지게 할 경우에만 유용하다.<br/>
그래서 기본키 제약은 이진 트리로 인덱스를 작성하는 데이터베이스가 많다.

<br/>

### 29강. 인덱스 작성과 삭제

```sql
CREATE INDEX 인덱스명 ON 테이블명 (열명1, 열명2, ...)
DROP INDEX 인덱스명 ON 테이블명
```

인덱스는 데이터베이스 객체로 DDL을 사용해서 작성하고 삭제할 수 있다.<br/>
인덱스를 작성할 때는 해당 인덱스가 어느 테이블의 어느 열에 관한 것인지 지정할 필요가 있다.<br/>
이때 열은 복수개로 지정할 수 있다.

테이블 크기에 따라 인덱스 작성 시간이 달라지는데 행이 대량으로 존재한다면 시간도 많이 걸리고 저장공간도 많이 소모된다.<br/>
따라서 적절한 열에 인덱스를 지정하는 것이 바람직하다.

- 실행 계획(EXPLAIN)

인덱스 작성을 통해 쿼리의 성능 향상을 기대할 수 있는데 이때 실제로 인덱스를 사용해 검색하는지를 확인하려면 EXPLAIN 명령을 사용해 확인한다.<br/>
다만 이 SQL명령을 실제로는 실행되지 않고 어떤 상태로 실행될 지를 데이터베이스가 설명해줄 뿐이다.

```sql
EXPLAIN SQL명령
```

인덱스는 서로 다른 값으로 여러 종류의 데이터가 존재할 때 그만큼 효율이 좋아진다.

<br/>

### 30강. 뷰 작성과 삭제

뷰 역시 데이터베이스 객체 중 하나로 데이터베이스 객체로 등록할 수 없는 SELECT 명령을 객체로서 이름을 붙여 관리한 것이다.<br/>
따라서 뷰를 참조하면 그에 정의된 SELECT 명령의 실행결과를 테이블처럼 사용할 수 있다.


FROM 절에 서브 쿼리를 사용할 수 있었지만 서브 쿼리를 뷰로 만들면 다음과 같은 쿼리를 만들 수 있다.

```sql
SELECT * FROM view_sample;
```

뷰를 사용함으로써 복잡한 SELECT문을 간략하게 표현할 수 있고 나중에 간단히 실행할 수도 있다.<br/>
즉, 자주 사용하거나 복잡한 SELECT 명령을 뷰로 만들어 편리하게 사용할 수 있다.

- 가상 테이블

뷰는 테이블처럼 취급할 수 있지만 '실체가 존재하지 않는다'라는 의미로 '가상 테이블'이라 불리기도 한다.<br/>
SELECT 명령으로 이루어지는 뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 저장공간을 가지지 않는다.<br/>
이 때문에 테이블처럼 취급할 수 있다고는 해도 SELECT 명령에서만 사용하는 것을 권장한다.


- 뷰의 작성과 삭제

```sql
CREATE VIEW 뷰명 AS SELECT명령
CREATE VIEW view_sample AS (SELECT * FROM sample);
CREATE VIEW view_sample(n, v, v2) AS (SELECT no, a, a*2 FROM sample);

DROP VIEW 뷰명
DROP VIEW view_sample;
```

- 뷰의 약점

뷰는 데이터베이스 객체로 저장장치게 저장되지만 테이블과 달리 대량의 저장공간을 필요로 하지 않는다.<br/>
데이터베이스에 저장되는 것은 SELECT 명령뿐이다. 다만 저장공간을 소모하지 않는 대신 CPU 자원을 사용한다.
