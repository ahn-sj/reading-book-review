열거 타입은 거의 모든 상황에서 타입 안전 열거 패턴(typesafe enum pattern)보다 우수하다.

---

타입 안전 열거 패턴(typesafe enum pattern)은 다음과 같다.
```java
public class Fruit {

    private String name;

    public static final Fruit APPLE = new Fruit("apple");
    public static final Fruit ORANGE = new Fruit("orange");
    public static final Fruit GRAPE = new Fruit("grape");

    private Fruit(String apple) {}
}
```

이 방식은 jdk 1.5이전에 Enum을 지원하지 않았기 때문에 생겨난 열거 패턴이다.<br/>
이러한 타입 안전 열거 패턴은 열거 타입보다 나은 점이 있는데, 그것은 타입 안전 텰거 패턴은 확장할 수 있으나 열거 타입은 그러지 못하다는 것이다.<br/>

달리 말하면, 타입 안전 열거 패턴은 열거한 값들을 그대로 가져온 다음 값을 더 추가하여<br/>
다른 목적으로 쓸 수 있는 반면, 열거 타입은 그렇게 하지 못한다.<br/>
실수로 이렇게 설계된 것이 아닌 대부분의 상황에서 열거 타입을 확장하는 것이 좋지 않기 때문이다.

> !! 이해하지 못한 부분
> 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 이상할 수 있다.<br/>
> 기반 타입과 확장된 타입들의 원소 모두를 순회할 방법도 마땅치 않다.

그런데, 열거 타입을 확장 가능한 쓰임이 있을 때도 있다.<br/>
바로 연산 코드(operation code)이다.<br/>
연산 코드의 각 원소는 수행하는 연산을 뜻한다.<br/>
이따금 API가 제공하는 기본 연산 외에 사용자 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있다.

기본 아이디어는 열거 타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다.<br/>
연산 코드용 인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게끔 하면 된다.<br/>
이때 열거 타입이 그 인터페이스의 표준 구현체 역할을 한다.
```java
public interface Operation {
    double apply(double x, double y);
}
```
```java
public enum BasicOperation implements Operation {

    PLUS("+") {
        @Override
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        public double apply(double x, double y) {
            return x - y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }
}
```

java 8 이상에서 람다를 활용하면 인터페이스없이도 함수를 상태값으로 갖는 열거 타입으로 변경할 수 있다.
```java
public enum LambdaOperation {

    PLUS("+", (x, y) -> x + y),
    MINUS("-", (x, y) -> x - y);

    private final String symbol;
    private final BiFunction<Double, Double, Double> func;

    LambdaOperation(String symbol, BiFunction<Double, Double, Double> func) {
        this.symbol = symbol;
        this.func = func;
    }
}
```

열거 타입인 BasicOperation은 확장할 수 없지만 인터페이스인 Operation은 확장 가능하기 때문에 Operation을 구현한 또 다른 열거 타입을 정의할 수 있게 된다.<br/>
예를 들어, 앞 연산 타입을 확장해 곱하기 연산과 나누기 연산을 추가해보자.

```java
public enum ExtendedOperation implements Operation {
    
    TIMES("^", (x, y) -> x * y),
    DIVIDE("%", (x, y) -> x / y);

    private final String symbol;
    private final BiFunction<Double, Double, Double> func;

    ExtendedOperation(String symbol, BiFunction<Double, Double, Double> func) {
        this.symbol = symbol;
        this.func = func;
    }

    @Override
    public double apply(double x, double y) {
        return func.apply(x, y);
    }

    @Override
    public String toString() {
        return symbol;
    }
}
```

위 코드와 같이 Operation 인터페이스를 구현한 열거 타입을 작성하기만 하면 된다.<br/>
또한, 인터페이스를 상속받아 구현했기 때문에 다형성의 이점을 살려 코드의 변경없이 사용 가능하다.

타입 수준에서도 기본 열거 타입 대신 확장된 열거 타입을 넘겨 다형성을 적용할 수 있다.<br/>
아래 예시는 ExtendedOperation의 모든 원소를 테스트하는 예시이다.
```java
public static void main(String[] args) {
    double x = 10.0;
    double y = 2.0;

    test(ExtendedOperation.class, x, y);
}

private static <T extends Enum<T> & Operation> void test(Class<T> opEnumType, double x, double y) {
    for (Operation op : opEnumType.getEnumConstants()) {
        System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
    }
}
```
```java
[실행 결과]
10.000000 ^ 2.000000 = 20.000000
10.000000 % 2.000000 = 5.000000
```


